

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Signing FreeBSD pkg Repositories with a YubiKey &mdash; banzai-plugins  documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=9edc463e" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=7f41d439"></script>
      <script src="../_static/doctools.js?v=fd6eb6e6"></script>
      <script src="../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="Metrics Exporter" href="../releases/26.1/metrics_exporter.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            banzai-plugins
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Plugin Releases</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../releases/26.1/index.html">OPNsense 26.1</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Articles</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Signing FreeBSD pkg Repositories with a YubiKey</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#why-hardware-backed-signing">Why hardware-backed signing?</a></li>
<li class="toctree-l2"><a class="reference internal" href="#how-pkg-signing-actually-works">How pkg signing actually works</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#the-double-hash">The double hash</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fingerprints">Fingerprints</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#setting-up-the-gpg-signing-key">Setting up the GPG signing key</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#generate-or-identify-your-signing-subkey">Generate or identify your signing subkey</a></li>
<li class="toctree-l3"><a class="reference internal" href="#export-the-public-key-in-pem-format">Export the public key in PEM format</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#the-signing-script">The signing script</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#why-gpg-connect-agent-instead-of-gpg-sign">Why gpg-connect-agent instead of gpg –sign?</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#gpg-agent-forwarding-for-remote-builds">GPG agent forwarding for remote builds</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#setup">Setup</a></li>
<li class="toctree-l3"><a class="reference internal" href="#the-stale-socket-trap">The stale socket trap</a></li>
<li class="toctree-l3"><a class="reference internal" href="#pin-entry">PIN entry</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#putting-it-together-the-build-script">Putting it together: the build script</a></li>
<li class="toctree-l2"><a class="reference internal" href="#client-side-setup">Client-side setup</a></li>
<li class="toctree-l2"><a class="reference internal" href="#verifying-signatures-manually">Verifying signatures manually</a></li>
<li class="toctree-l2"><a class="reference internal" href="#summary-of-pitfalls">Summary of pitfalls</a></li>
<li class="toctree-l2"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">banzai-plugins</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Signing FreeBSD pkg Repositories with a YubiKey</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="signing-freebsd-pkg-repositories-with-a-yubikey">
<h1>Signing FreeBSD pkg Repositories with a YubiKey<a class="headerlink" href="#signing-freebsd-pkg-repositories-with-a-yubikey" title="Link to this heading"></a></h1>
<p>FreeBSD’s <code class="docutils literal notranslate"><span class="pre">pkg</span></code> supports cryptographic signing of package repositories.
It uses its own signing protocol with a double-hash scheme and a specific
stdin/stdout contract for signing commands. This article walks through signing a
<code class="docutils literal notranslate"><span class="pre">pkg</span> <span class="pre">repo</span></code> with a GPG key stored on a YubiKey, including GPG agent forwarding
for remote builds.</p>
<section id="why-hardware-backed-signing">
<h2>Why hardware-backed signing?<a class="headerlink" href="#why-hardware-backed-signing" title="Link to this heading"></a></h2>
<p>A pkg repository signing key is a high-value target. If the private key is
compromised, an attacker can push malicious packages to every machine that
trusts the repo. Storing the signing key on a YubiKey means the private key
never exists on disk – signing operations happen on the hardware token, which
is designed to prevent extraction of private keys.</p>
</section>
<section id="how-pkg-signing-actually-works">
<h2>How pkg signing actually works<a class="headerlink" href="#how-pkg-signing-actually-works" title="Link to this heading"></a></h2>
<p>Before writing any code, you need to understand what <code class="docutils literal notranslate"><span class="pre">pkg</span> <span class="pre">repo</span></code> actually does
when it signs. The
<a class="reference external" href="https://man.freebsd.org/cgi/man.cgi?query=pkg-repo&amp;sektion=8">pkg-repo(8)</a>
man page <a class="footnote-reference brackets" href="#id9" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> documents the output format (<code class="docutils literal notranslate"><span class="pre">SIGNATURE</span></code>/<code class="docutils literal notranslate"><span class="pre">CERT</span></code>/<code class="docutils literal notranslate"><span class="pre">END</span></code>) and
states that the signing command receives “the SHA256 of the repository catalogue
on its stdin.” However, it does not describe the double-hash verification
scheme, the fact that stdin remains open, or how fingerprints are computed.</p>
<p>When you run:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>pkg<span class="w"> </span>repo<span class="w"> </span>/path/to/repo/<span class="w"> </span>signing_command:<span class="w"> </span>/path/to/sign.sh
</pre></div>
</div>
<p>pkg computes <code class="docutils literal notranslate"><span class="pre">SHA256(data)</span></code> as a <strong>64-character lowercase hex string</strong> and
pipes it to your signing command’s stdin. Your command must output a response in
this format:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SIGNATURE</span>
<span class="o">&lt;</span><span class="n">binary</span> <span class="n">signature</span> <span class="nb">bytes</span><span class="o">&gt;</span>
<span class="n">CERT</span>
<span class="o">&lt;</span><span class="n">PEM</span> <span class="n">public</span> <span class="n">key</span><span class="o">&gt;</span>
<span class="n">END</span>
</pre></div>
</div>
<p>The critical detail: <strong>pkg keeps stdin open</strong> while it waits for the signing
command’s response, only closing it during cleanup <a class="footnote-reference brackets" href="#id13" id="id2" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a>. This means <code class="docutils literal notranslate"><span class="pre">cat</span></code> will
deadlock waiting for EOF. The official example script <a class="footnote-reference brackets" href="#id11" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a> in the pkg repository
uses <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">-t</span> <span class="pre">2</span></code> (with a 2-second timeout) to handle this.</p>
<section id="the-double-hash">
<h3>The double hash<a class="headerlink" href="#the-double-hash" title="Link to this heading"></a></h3>
<p>pkg sends <code class="docutils literal notranslate"><span class="pre">SHA256_hex(data)</span></code> – a hex string –
on stdin. But when it <em>verifies</em> the signature, it computes
<code class="docutils literal notranslate"><span class="pre">SHA256(hex_string)</span></code> and checks the signature against <em>that</em>. The hash that
gets signed is:</p>
<div class="highlight-text notranslate"><div class="highlight"><pre><span></span>SHA256(SHA256_hex(data))
</pre></div>
</div>
<p>This is a double hash: SHA256 of the data produces a hex string, then SHA256 of
that hex string produces the 32-byte digest that ends up in the RSA signature’s
DigestInfo structure.</p>
<p>If you sign the hex string directly (without hashing it again),
<code class="docutils literal notranslate"><span class="pre">openssl</span> <span class="pre">dgst</span> <span class="pre">-verify</span></code> will validate your signature – but <code class="docutils literal notranslate"><span class="pre">pkg</span></code> will
reject it. <code class="docutils literal notranslate"><span class="pre">openssl</span> <span class="pre">dgst</span> <span class="pre">-verify</span></code> tests a single hash, not the double hash
that pkg expects, so it is not a valid test for pkg signatures.</p>
<p>The correct signature format is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">RSA</span><span class="p">(</span><span class="n">PKCS</span><span class="c1">#1 v1.5(DigestInfo(SHA256_OID, SHA256(hex_string))))</span>
</pre></div>
</div>
<p>This is confirmed by the verification code in <code class="docutils literal notranslate"><span class="pre">libpkg/pkgsign_ossl.c</span></code> <a class="footnote-reference brackets" href="#id12" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>.
The function <code class="docutils literal notranslate"><span class="pre">ossl_verify_cb</span></code> calls <code class="docutils literal notranslate"><span class="pre">pkg_checksum_fd()</span></code> to get the hex hash,
then passes the 64-byte hex string directly to <code class="docutils literal notranslate"><span class="pre">EVP_PKEY_verify</span></code> with a
custom digest <code class="docutils literal notranslate"><span class="pre">EVP_md_pkg_sha1()</span></code>. This custom digest has the SHA-1 OID but
an overridden result size of 64. In practice with OpenSSL 3.x, signatures using
the SHA-256 OID and 32-byte hash also verify correctly.</p>
</section>
<section id="fingerprints">
<h3>Fingerprints<a class="headerlink" href="#fingerprints" title="Link to this heading"></a></h3>
<p>pkg identifies trusted signing keys by fingerprint. The fingerprint is
<code class="docutils literal notranslate"><span class="pre">SHA256</span></code> of the <strong>entire PEM file</strong> – including the
<code class="docutils literal notranslate"><span class="pre">-----BEGIN/END-----</span></code> headers and trailing newline:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="c1"># Correct:</span>
shasum<span class="w"> </span>-a<span class="w"> </span><span class="m">256</span><span class="w"> </span>repo.pub

<span class="c1"># WRONG -- gives a different hash:</span>
openssl<span class="w"> </span>rsa<span class="w"> </span>-pubin<span class="w"> </span>-outform<span class="w"> </span>DER<span class="w"> </span>&lt;<span class="w"> </span>repo.pub<span class="w"> </span><span class="p">|</span><span class="w"> </span>shasum<span class="w"> </span>-a<span class="w"> </span><span class="m">256</span>
</pre></div>
</div>
<p>The fingerprint is not a hash of the DER-encoded public key material. It’s a
hash of the PEM file as-is <a class="footnote-reference brackets" href="#id14" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>6<span class="fn-bracket">]</span></a>.</p>
</section>
</section>
<section id="setting-up-the-gpg-signing-key">
<h2>Setting up the GPG signing key<a class="headerlink" href="#setting-up-the-gpg-signing-key" title="Link to this heading"></a></h2>
<section id="generate-or-identify-your-signing-subkey">
<h3>Generate or identify your signing subkey<a class="headerlink" href="#generate-or-identify-your-signing-subkey" title="Link to this heading"></a></h3>
<p>If you already have a GPG key on your YubiKey, identify the signing subkey:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>gpg<span class="w"> </span>--list-keys<span class="w"> </span>--with-keygrip<span class="w"> </span>your@email.com
</pre></div>
</div>
<p>Look for a subkey with <code class="docutils literal notranslate"><span class="pre">[S]</span></code> (signing) capability and note its <strong>keygrip</strong> –
a 40-character hex string. The keygrip identifies the key to <code class="docutils literal notranslate"><span class="pre">gpg-agent</span></code>
regardless of the key’s OpenPGP metadata.</p>
<p>If you need to generate a new signing subkey and move it to your YubiKey,
see one of these guides:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://developers.yubico.com/PGP/PGP_Walk-Through.html">Yubico PGP Walk-Through</a>
– Yubico’s official guide to generating PGP keys and loading them onto a
YubiKey.</p></li>
<li><p><a class="reference external" href="https://github.com/drduh/YubiKey-Guide">drduh/YubiKey-Guide</a> – detailed
community guide covering key generation, subkey creation, and transfer to
YubiKey with full console output examples.</p></li>
</ul>
</section>
<section id="export-the-public-key-in-pem-format">
<h3>Export the public key in PEM format<a class="headerlink" href="#export-the-public-key-in-pem-format" title="Link to this heading"></a></h3>
<p>pkg needs a PKCS#8 PEM public key, not a GPG public key. If the key was created
outside GPG and imported, you may already have the PEM file. If the key was
generated on the YubiKey via GPG, you can extract it with <code class="docutils literal notranslate"><span class="pre">gpg-connect-agent</span></code>
and convert it to PEM. <code class="docutils literal notranslate"><span class="pre">gpg-connect-agent</span></code> returns key material as
S-expressions – a length-prefixed binary format (e.g. <code class="docutils literal notranslate"><span class="pre">3:rsa</span></code> means “3 bytes:
rsa”, <code class="docutils literal notranslate"><span class="pre">1:n512:&lt;bytes&gt;</span></code> means “field n, 512 bytes of data”):</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>python3<span class="w"> </span><span class="s">&lt;&lt; &#39;PYEOF&#39; &gt; repo.pub</span>
<span class="s">import subprocess, re, base64, sys</span>

<span class="s">KEYGRIP = &quot;&lt;your-keygrip-here&gt;&quot;</span>

<span class="s">result = subprocess.run(</span>
<span class="s">    [&quot;gpg-connect-agent&quot;, f&quot;READKEY {KEYGRIP}&quot;, &quot;/bye&quot;],</span>
<span class="s">    capture_output=True</span>
<span class="s">)</span>

<span class="s"># Decode Assuan protocol D lines (%-encoded binary)</span>
<span class="s">data_parts = []</span>
<span class="s">for line in result.stdout.split(b&#39;\n&#39;):</span>
<span class="s">    if line.startswith(b&#39;D &#39;):</span>
<span class="s">        part = line[2:]</span>
<span class="s">        decoded = b&#39;&#39;</span>
<span class="s">        i = 0</span>
<span class="s">        while i &lt; len(part):</span>
<span class="s">            if part[i:i+1] == b&#39;%&#39; and i+2 &lt; len(part):</span>
<span class="s">                decoded += bytes([int(part[i+1:i+3], 16)])</span>
<span class="s">                i += 3</span>
<span class="s">            else:</span>
<span class="s">                decoded += part[i:i+1]</span>
<span class="s">                i += 1</span>
<span class="s">        data_parts.append(decoded)</span>
<span class="s">sexp = b&#39;&#39;.join(data_parts)</span>

<span class="s"># Parse n and e from S-expression:</span>
<span class="s"># (10:public-key(3:rsa(1:n&lt;len&gt;:&lt;n&gt;)(1:e&lt;len&gt;:&lt;e&gt;)))</span>
<span class="s">n_match = re.search(rb&#39;\(1:n(\d+):&#39;, sexp)</span>
<span class="s">n_len = int(n_match.group(1))</span>
<span class="s">n_bytes = sexp[n_match.end():n_match.end()+n_len]</span>
<span class="s">e_start = n_match.end() + n_len</span>
<span class="s">e_match = re.search(rb&#39;\(1:e(\d+):&#39;, sexp[e_start:])</span>
<span class="s">e_len = int(e_match.group(1))</span>
<span class="s">e_bytes = sexp[e_start + e_match.end():e_start + e_match.end() + e_len]</span>

<span class="s">n_int = int.from_bytes(n_bytes, &#39;big&#39;)</span>
<span class="s">e_int = int.from_bytes(e_bytes, &#39;big&#39;)</span>

<span class="s"># Build DER-encoded SubjectPublicKeyInfo</span>
<span class="s">def der_integer(value):</span>
<span class="s">    b = value.to_bytes((value.bit_length() + 8) // 8, &#39;big&#39;)</span>
<span class="s">    return b&#39;\x02&#39; + der_length(len(b)) + b</span>
<span class="s">def der_length(l):</span>
<span class="s">    if l &lt; 128: return bytes([l])</span>
<span class="s">    elif l &lt; 256: return b&#39;\x81&#39; + bytes([l])</span>
<span class="s">    else: return b&#39;\x82&#39; + l.to_bytes(2, &#39;big&#39;)</span>
<span class="s">def der_sequence(data):</span>
<span class="s">    return b&#39;\x30&#39; + der_length(len(data)) + data</span>

<span class="s">rsa_pub = der_sequence(der_integer(n_int) + der_integer(e_int))</span>
<span class="s">rsa_oid = b&#39;\x30\x0d\x06\x09\x2a\x86\x48\x86\xf7\x0d\x01\x01\x01\x05\x00&#39;</span>
<span class="s">bit_string = b&#39;\x03&#39; + der_length(len(rsa_pub) + 1) + b&#39;\x00&#39; + rsa_pub</span>
<span class="s">spki = der_sequence(rsa_oid + bit_string)</span>

<span class="s">pem = b&#39;-----BEGIN PUBLIC KEY-----\n&#39;</span>
<span class="s">pem += base64.encodebytes(spki)</span>
<span class="s">pem += b&#39;-----END PUBLIC KEY-----\n&#39;</span>
<span class="s">sys.stdout.buffer.write(pem)</span>
<span class="s">PYEOF</span>
</pre></div>
</div>
<p>This uses <code class="docutils literal notranslate"><span class="pre">READKEY</span></code> to read the raw RSA public key from the YubiKey, parses
the modulus and exponent from the gpg-agent S-expression, and constructs a
standard PKCS#8 PEM file. The result should look like:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-----</span><span class="n">BEGIN</span> <span class="n">PUBLIC</span> <span class="n">KEY</span><span class="o">-----</span>
<span class="n">MIICIjANBgkqhkiG9w0BAQEFAAOC</span><span class="o">...</span>
<span class="o">-----</span><span class="n">END</span> <span class="n">PUBLIC</span> <span class="n">KEY</span><span class="o">-----</span>
</pre></div>
</div>
</section>
</section>
<section id="the-signing-script">
<h2>The signing script<a class="headerlink" href="#the-signing-script" title="Link to this heading"></a></h2>
<p>This script is called by <code class="docutils literal notranslate"><span class="pre">pkg</span> <span class="pre">repo</span></code> as the <code class="docutils literal notranslate"><span class="pre">signing_command</span></code>. It reads the
hex hash from stdin, performs the double hash, signs via <code class="docutils literal notranslate"><span class="pre">gpg-agent</span></code>, and
outputs the result in pkg’s expected format.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python3</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">hashlib</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">subprocess</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>

<span class="n">DEFAULT_KEYGRIP</span> <span class="o">=</span> <span class="s2">&quot;&lt;your-keygrip-here&gt;&quot;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">find_repo_pub</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Locate the public key PEM file.&quot;&quot;&quot;</span>
    <span class="n">env_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;REPO_PUB&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">env_path</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">env_path</span>
    <span class="n">script_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">script_dir</span><span class="p">,</span> <span class="s2">&quot;repo.pub&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">path</span>
    <span class="n">repo_root</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">script_dir</span><span class="p">)</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">repo_root</span><span class="p">,</span> <span class="s2">&quot;Keys&quot;</span><span class="p">,</span> <span class="s2">&quot;repo.pub&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">path</span>
    <span class="k">return</span> <span class="kc">None</span>


<span class="k">def</span><span class="w"> </span><span class="nf">decode_assuan_data</span><span class="p">(</span><span class="n">stdout</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Decode Assuan protocol D lines (%-encoded binary) and concatenate.&quot;&quot;&quot;</span>
    <span class="n">data_parts</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">stdout</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;D &quot;</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="n">part</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
        <span class="n">decoded</span> <span class="o">=</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">part</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">part</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sa">b</span><span class="s2">&quot;%&quot;</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">part</span><span class="p">):</span>
                <span class="n">decoded</span> <span class="o">+=</span> <span class="nb">bytes</span><span class="p">([</span><span class="nb">int</span><span class="p">(</span><span class="n">part</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">],</span> <span class="mi">16</span><span class="p">)])</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">3</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">decoded</span> <span class="o">+=</span> <span class="n">part</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">data_parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">decoded</span><span class="p">)</span>
    <span class="k">return</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_parts</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">extract_rsa_signature</span><span class="p">(</span><span class="n">sexp</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extract raw RSA signature bytes from a gpg-agent S-expression.</span>

<span class="sd">    The S-expression has the form: (7:sig-val(3:rsa(1:s&lt;len&gt;:&lt;sig&gt;)))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">rb</span><span class="s2">&quot;\(1:s(\d+):&quot;</span><span class="p">,</span> <span class="n">sexp</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
        <span class="n">die</span><span class="p">(</span><span class="s2">&quot;could not parse signature S-expression&quot;</span><span class="p">)</span>
    <span class="n">sig_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">sexp</span><span class="p">[</span><span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">():</span><span class="n">m</span><span class="o">.</span><span class="n">end</span><span class="p">()</span> <span class="o">+</span> <span class="n">sig_len</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="o">!=</span> <span class="n">sig_len</span><span class="p">:</span>
        <span class="n">die</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;expected </span><span class="si">{</span><span class="n">sig_len</span><span class="si">}</span><span class="s2"> byte signature, got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sig</span>


<span class="k">def</span><span class="w"> </span><span class="nf">die</span><span class="p">(</span><span class="n">msg</span><span class="p">):</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ERROR: </span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">():</span>
    <span class="n">keygrip</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;GPG_SIGN_KEYGRIP&quot;</span><span class="p">,</span> <span class="n">DEFAULT_KEYGRIP</span><span class="p">)</span>

    <span class="n">repo_pub</span> <span class="o">=</span> <span class="n">find_repo_pub</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">repo_pub</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">repo_pub</span><span class="p">):</span>
        <span class="n">die</span><span class="p">(</span><span class="s2">&quot;public key not found (searched REPO_PUB, script dir, Keys/)&quot;</span><span class="p">)</span>

    <span class="c1"># pkg repo sends SHA256(data) as a hex string on stdin. It doesn&#39;t</span>
    <span class="c1"># close stdin, so read one line only. pkg verifies against</span>
    <span class="c1"># SHA256(hex_string), so hash it again.</span>
    <span class="n">hex_hash</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stdin</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">hex_hash</span><span class="p">:</span>
        <span class="n">die</span><span class="p">(</span><span class="s2">&quot;no hash received on stdin&quot;</span><span class="p">)</span>

    <span class="n">double_hash</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha256</span><span class="p">(</span><span class="n">hex_hash</span><span class="o">.</span><span class="n">encode</span><span class="p">())</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>

    <span class="c1"># Sign via gpg-agent: SIGKEY selects the key, SETHASH sets the</span>
    <span class="c1"># digest, PKSIGN produces the signature. PIN prompting goes</span>
    <span class="c1"># through pinentry.</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">run</span><span class="p">(</span>
        <span class="p">[</span><span class="s2">&quot;gpg-connect-agent&quot;</span><span class="p">,</span>
         <span class="sa">f</span><span class="s2">&quot;SIGKEY </span><span class="si">{</span><span class="n">keygrip</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
         <span class="sa">f</span><span class="s2">&quot;SETHASH --hash=sha256 </span><span class="si">{</span><span class="n">double_hash</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
         <span class="s2">&quot;PKSIGN&quot;</span><span class="p">,</span> <span class="s2">&quot;/bye&quot;</span><span class="p">],</span>
        <span class="n">capture_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">returncode</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">die</span><span class="p">(</span><span class="s2">&quot;gpg-connect-agent failed&quot;</span><span class="p">)</span>

    <span class="n">sexp</span> <span class="o">=</span> <span class="n">decode_assuan_data</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">extract_rsa_signature</span><span class="p">(</span><span class="n">sexp</span><span class="p">)</span>

    <span class="c1"># Output in the format pkg expects</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">repo_pub</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">pub_pem</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;SIGNATURE</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">sig</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">CERT</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">pub_pem</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;END</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">buffer</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
<section id="why-gpg-connect-agent-instead-of-gpg-sign">
<h3>Why gpg-connect-agent instead of gpg –sign?<a class="headerlink" href="#why-gpg-connect-agent-instead-of-gpg-sign" title="Link to this heading"></a></h3>
<p><code class="docutils literal notranslate"><span class="pre">gpg</span> <span class="pre">--sign</span></code> produces OpenPGP-format signatures, which are completely
different from what pkg expects. pkg needs a raw PKCS#1 v1.5 RSA signature. The
<code class="docutils literal notranslate"><span class="pre">gpg-connect-agent</span></code> command talks directly to the agent daemon using the
Assuan protocol, giving us access to the low-level <code class="docutils literal notranslate"><span class="pre">PKSIGN</span></code> operation that
returns a raw RSA signature wrapped in an S-expression.</p>
<p>The Assuan protocol is GnuPG’s line-based IPC protocol. Responses come as
single-letter prefixed lines: <code class="docutils literal notranslate"><span class="pre">OK</span></code> for success, <code class="docutils literal notranslate"><span class="pre">ERR</span></code> for errors, and
<code class="docutils literal notranslate"><span class="pre">D</span></code> for data. Binary payloads are returned on <code class="docutils literal notranslate"><span class="pre">D</span></code> lines with special bytes
percent-encoded (e.g. <code class="docutils literal notranslate"><span class="pre">%25</span></code> for <code class="docutils literal notranslate"><span class="pre">%</span></code>, <code class="docutils literal notranslate"><span class="pre">%0A</span></code> for newline). Large responses
may span multiple <code class="docutils literal notranslate"><span class="pre">D</span></code> lines that need to be concatenated after decoding.</p>
<p>The signing flow is:</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">SIGKEY</span> <span class="pre">&lt;keygrip&gt;</span></code> – select the signing key</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">SETHASH</span> <span class="pre">--hash=sha256</span> <span class="pre">&lt;hex&gt;</span></code> – set the hash to sign</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PKSIGN</span></code> – produce the signature</p></li>
</ol>
<p>The agent returns the signature on <code class="docutils literal notranslate"><span class="pre">D</span></code> lines as an S-expression:
<code class="docutils literal notranslate"><span class="pre">(sig-val(rsa(s&lt;len&gt;:&lt;bytes&gt;)))</span></code>. The Python code decodes the percent-encoded
<code class="docutils literal notranslate"><span class="pre">D</span></code> lines and extracts the raw signature bytes.</p>
</section>
</section>
<section id="gpg-agent-forwarding-for-remote-builds">
<h2>GPG agent forwarding for remote builds<a class="headerlink" href="#gpg-agent-forwarding-for-remote-builds" title="Link to this heading"></a></h2>
<p>In many setups, packages are built on a remote FreeBSD machine but the YubiKey
is plugged into your local workstation. GPG agent forwarding over SSH <a class="footnote-reference brackets" href="#id16" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>8<span class="fn-bracket">]</span></a>
solves this: the remote machine’s <code class="docutils literal notranslate"><span class="pre">gpg-connect-agent</span></code> commands are
transparently forwarded to your local agent, which talks to the YubiKey.</p>
<section id="setup">
<h3>Setup<a class="headerlink" href="#setup" title="Link to this heading"></a></h3>
<p>SSH’s <code class="docutils literal notranslate"><span class="pre">-R</span></code> flag creates a remote Unix socket that forwards to a local one:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get socket paths</span>
<span class="nv">REMOTE_GPG_SOCK</span><span class="o">=</span><span class="k">$(</span>ssh<span class="w"> </span>remote-host<span class="w"> </span><span class="s2">&quot;gpgconf --list-dirs agent-socket&quot;</span><span class="k">)</span>
<span class="nv">LOCAL_GPG_EXTRA</span><span class="o">=</span><span class="k">$(</span>gpgconf<span class="w"> </span>--list-dirs<span class="w"> </span>agent-extra-socket<span class="k">)</span>

<span class="c1"># Kill any existing remote agent -- critical!</span>
ssh<span class="w"> </span>remote-host<span class="w"> </span><span class="s2">&quot;gpgconf --kill gpg-agent; rm -f </span><span class="si">${</span><span class="nv">REMOTE_GPG_SOCK</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># Connect with agent forwarding</span>
ssh<span class="w"> </span>-R<span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">REMOTE_GPG_SOCK</span><span class="si">}</span><span class="s2">:</span><span class="si">${</span><span class="nv">LOCAL_GPG_EXTRA</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span>remote-host<span class="w"> </span><span class="se">\</span>
<span class="w">    </span><span class="s2">&quot;pkg repo /path/to/repo/ signing_command: /path/to/sign-repo.py&quot;</span>
</pre></div>
</div>
<p>The <strong>extra socket</strong> (<code class="docutils literal notranslate"><span class="pre">agent-extra-socket</span></code>) is a socket that GPG provides
specifically for forwarding to remote machines <a class="footnote-reference brackets" href="#id15" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>7<span class="fn-bracket">]</span></a>.
It is more restricted than the standard agent socket.</p>
</section>
<section id="the-stale-socket-trap">
<h3>The stale socket trap<a class="headerlink" href="#the-stale-socket-trap" title="Link to this heading"></a></h3>
<p>If a <code class="docutils literal notranslate"><span class="pre">gpg-agent</span></code> is already running on
the remote (or a stale socket file exists), SSH’s <code class="docutils literal notranslate"><span class="pre">-R</span></code> forwarding will fail
silently – the remote socket file already exists, so SSH can’t create its
forwarded socket. You’ll get <code class="docutils literal notranslate"><span class="pre">remote</span> <span class="pre">port</span> <span class="pre">forwarding</span> <span class="pre">failed</span> <span class="pre">for</span> <span class="pre">listen</span> <span class="pre">path</span></code>
in the SSH output, but the connection proceeds without forwarding. Then
<code class="docutils literal notranslate"><span class="pre">gpg-connect-agent</span></code> on the remote talks to the local (remote machine’s) agent
instead of your forwarded one, and signing fails because the key isn’t there.</p>
<p>The fix: <strong>always kill the remote gpg-agent and remove the socket in a separate
SSH call before the -R connection</strong>:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>ssh<span class="w"> </span>remote-host<span class="w"> </span><span class="s2">&quot;gpgconf --kill gpg-agent; rm -f </span><span class="si">${</span><span class="nv">REMOTE_GPG_SOCK</span><span class="si">}</span><span class="s2">&quot;</span>
ssh<span class="w"> </span>-R<span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">REMOTE_GPG_SOCK</span><span class="si">}</span><span class="s2">:</span><span class="si">${</span><span class="nv">LOCAL_GPG_EXTRA</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span>remote-host<span class="w"> </span><span class="s2">&quot;...&quot;</span>
</pre></div>
</div>
<p>This must be two separate SSH calls. If you put the kill and the <code class="docutils literal notranslate"><span class="pre">ssh</span> <span class="pre">-R</span></code> in
the same command, the forwarding is set up at connection time – before your
kill command runs.</p>
</section>
<section id="pin-entry">
<h3>PIN entry<a class="headerlink" href="#pin-entry" title="Link to this heading"></a></h3>
<p>When the signing operation reaches the YubiKey, it prompts for the user PIN via
<code class="docutils literal notranslate"><span class="pre">pinentry</span></code>. On macOS with <code class="docutils literal notranslate"><span class="pre">pinentry-mac</span></code>, this is a GUI dialog on your
local machine. On Linux, <code class="docutils literal notranslate"><span class="pre">pinentry-curses</span></code> or <code class="docutils literal notranslate"><span class="pre">pinentry-gnome3</span></code> will prompt
on your local terminal or desktop. The remote machine never sees the PIN.</p>
</section>
</section>
<section id="putting-it-together-the-build-script">
<h2>Putting it together: the build script<a class="headerlink" href="#putting-it-together-the-build-script" title="Link to this heading"></a></h2>
<p>Here’s the signing section of a build script that builds packages on a remote
FreeBSD host and signs the repo via agent forwarding:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="c1"># Upload the signing script and public key</span>
scp<span class="w"> </span>-q<span class="w"> </span>tools/sign-repo.py<span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">FIREWALL</span><span class="si">}</span><span class="s2">:</span><span class="si">${</span><span class="nv">REMOTE_REPO_DIR</span><span class="si">}</span><span class="s2">/sign-repo.py&quot;</span>
scp<span class="w"> </span>-q<span class="w"> </span>Keys/repo.pub<span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">FIREWALL</span><span class="si">}</span><span class="s2">:</span><span class="si">${</span><span class="nv">REMOTE_REPO_DIR</span><span class="si">}</span><span class="s2">/repo.pub&quot;</span>

<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Signing repo (GPG key on this host via agent forwarding)...&quot;</span>
<span class="nv">REMOTE_GPG_SOCK</span><span class="o">=</span><span class="k">$(</span>ssh<span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">FIREWALL</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span><span class="s2">&quot;gpgconf --list-dirs agent-socket&quot;</span><span class="k">)</span>
<span class="nv">LOCAL_GPG_EXTRA</span><span class="o">=</span><span class="k">$(</span>gpgconf<span class="w"> </span>--list-dirs<span class="w"> </span>agent-extra-socket<span class="k">)</span>

<span class="c1"># Kill remote agent and remove stale socket before forwarding</span>
ssh<span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">FIREWALL</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span><span class="s2">&quot;gpgconf --kill gpg-agent; rm -f </span><span class="si">${</span><span class="nv">REMOTE_GPG_SOCK</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="c1"># Sign with forwarded agent</span>
ssh<span class="w"> </span>-R<span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">REMOTE_GPG_SOCK</span><span class="si">}</span><span class="s2">:</span><span class="si">${</span><span class="nv">LOCAL_GPG_EXTRA</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">FIREWALL</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">    </span><span class="s2">&quot;pkg repo </span><span class="si">${</span><span class="nv">REMOTE_REPO_DIR</span><span class="si">}</span><span class="s2">/ signing_command: </span><span class="si">${</span><span class="nv">REMOTE_REPO_DIR</span><span class="si">}</span><span class="s2">/sign-repo.py&quot;</span>

<span class="c1"># Verify signing succeeded (pkg repo exits 0 even on failure)</span>
ssh<span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">FIREWALL</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span><span class="s2">&quot;test -f </span><span class="si">${</span><span class="nv">REMOTE_REPO_DIR</span><span class="si">}</span><span class="s2">/meta.conf&quot;</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;ERROR: Repo signing failed&quot;</span><span class="w"> </span>&gt;<span class="p">&amp;</span><span class="m">2</span>
<span class="w">    </span><span class="nb">exit</span><span class="w"> </span><span class="m">1</span>
<span class="o">}</span>

<span class="c1"># Clean up signing artifacts before downloading</span>
ssh<span class="w"> </span><span class="s2">&quot;</span><span class="si">${</span><span class="nv">FIREWALL</span><span class="si">}</span><span class="s2">&quot;</span><span class="w"> </span><span class="s2">&quot;rm -f </span><span class="si">${</span><span class="nv">REMOTE_REPO_DIR</span><span class="si">}</span><span class="s2">/sign-repo.py </span><span class="si">${</span><span class="nv">REMOTE_REPO_DIR</span><span class="si">}</span><span class="s2">/repo.pub&quot;</span>
</pre></div>
</div>
<p>Note the <code class="docutils literal notranslate"><span class="pre">meta.conf</span></code> check: <code class="docutils literal notranslate"><span class="pre">pkg</span> <span class="pre">repo</span></code> exits 0 even when signing fails, so
you need to verify the output explicitly.</p>
</section>
<section id="client-side-setup">
<h2>Client-side setup<a class="headerlink" href="#client-side-setup" title="Link to this heading"></a></h2>
<p>On each machine that should trust the repo, install the fingerprint <a class="footnote-reference brackets" href="#id10" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>mkdir<span class="w"> </span>-p<span class="w"> </span>/usr/local/etc/pkg/fingerprints/myrepo/trusted
mkdir<span class="w"> </span>-p<span class="w"> </span>/usr/local/etc/pkg/fingerprints/myrepo/revoked

<span class="c1"># Fingerprint is SHA256 of the PEM file (not the DER key)</span>
<span class="nv">FINGERPRINT</span><span class="o">=</span><span class="k">$(</span>shasum<span class="w"> </span>-a<span class="w"> </span><span class="m">256</span><span class="w"> </span>repo.pub<span class="w"> </span><span class="p">|</span><span class="w"> </span>awk<span class="w"> </span><span class="s1">&#39;{print $1}&#39;</span><span class="k">)</span>

cat<span class="w"> </span>&gt;<span class="w"> </span>/usr/local/etc/pkg/fingerprints/myrepo/trusted/repo.fingerprint<span class="w"> </span><span class="s">&lt;&lt;EOF</span>
<span class="s">function: sha256</span>
<span class="s">fingerprint: ${FINGERPRINT}</span>
<span class="s">EOF</span>
</pre></div>
</div>
<p>Then add the repository configuration:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span>cat<span class="w"> </span>&gt;<span class="w"> </span>/usr/local/etc/pkg/repos/myrepo.conf<span class="w"> </span><span class="s">&lt;&lt;&#39;EOF&#39;</span>
<span class="s">myrepo: {</span>
<span class="s">  url: &quot;https://example.com/packages/${ABI}/repo&quot;,</span>
<span class="s">  signature_type: &quot;fingerprints&quot;,</span>
<span class="s">  fingerprints: &quot;/usr/local/etc/pkg/fingerprints/myrepo&quot;,</span>
<span class="s">  enabled: yes</span>
<span class="s">}</span>
<span class="s">EOF</span>

pkg<span class="w"> </span>update<span class="w"> </span>-f<span class="w"> </span>-r<span class="w"> </span>myrepo
</pre></div>
</div>
</section>
<section id="verifying-signatures-manually">
<h2>Verifying signatures manually<a class="headerlink" href="#verifying-signatures-manually" title="Link to this heading"></a></h2>
<p>You can’t use <code class="docutils literal notranslate"><span class="pre">openssl</span> <span class="pre">dgst</span> <span class="pre">-verify</span></code> – it tests the wrong thing. Instead,
extract and inspect the DigestInfo:</p>
<div class="highlight-sh notranslate"><div class="highlight"><pre><span></span><span class="c1"># Extract signature components from the repo archive</span>
tar<span class="w"> </span>-xf<span class="w"> </span>data.pkg<span class="w"> </span>data<span class="w"> </span>data.pub<span class="w"> </span>data.sig

<span class="c1"># Decrypt the signature to see the DigestInfo</span>
openssl<span class="w"> </span>rsautl<span class="w"> </span>-verify<span class="w"> </span>-pubin<span class="w"> </span>-inkey<span class="w"> </span>data.pub<span class="w"> </span>-in<span class="w"> </span>data.sig<span class="w"> </span><span class="m">2</span>&gt;/dev/null<span class="w"> </span><span class="se">\</span>
<span class="w">    </span><span class="p">|</span><span class="w"> </span>od<span class="w"> </span>-A<span class="w"> </span>x<span class="w"> </span>-t<span class="w"> </span>x1<span class="w"> </span><span class="p">|</span><span class="w"> </span>tail<span class="w"> </span>-4

<span class="c1"># Compute the expected hash (double SHA256):</span>
<span class="nb">printf</span><span class="w"> </span><span class="s1">&#39;%s&#39;</span><span class="w"> </span><span class="s2">&quot;</span><span class="k">$(</span>openssl<span class="w"> </span>dgst<span class="w"> </span>-sha256<span class="w"> </span>-hex<span class="w"> </span>data<span class="w"> </span><span class="p">|</span><span class="w"> </span>awk<span class="w"> </span><span class="s1">&#39;{print $NF}&#39;</span><span class="k">)</span><span class="s2">&quot;</span><span class="w"> </span><span class="se">\</span>
<span class="w">    </span><span class="p">|</span><span class="w"> </span>openssl<span class="w"> </span>dgst<span class="w"> </span>-sha256<span class="w"> </span>-hex<span class="w"> </span><span class="p">|</span><span class="w"> </span>awk<span class="w"> </span><span class="s1">&#39;{print $NF}&#39;</span>
</pre></div>
</div>
<p>The last 32 bytes of the DigestInfo from the first command should match the
hash from the second command.</p>
</section>
<section id="summary-of-pitfalls">
<h2>Summary of pitfalls<a class="headerlink" href="#summary-of-pitfalls" title="Link to this heading"></a></h2>
<table class="docutils align-default">
<colgroup>
<col style="width: 25.0%" />
<col style="width: 35.0%" />
<col style="width: 40.0%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Pitfall</p></th>
<th class="head"><p>Symptom</p></th>
<th class="head"><p>Fix</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Signing hex hash directly</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">openssl</span> <span class="pre">dgst</span> <span class="pre">-verify</span></code> passes but <code class="docutils literal notranslate"><span class="pre">pkg</span></code> rejects</p></td>
<td><p>Hash the hex string again with SHA256 before signing</p></td>
</tr>
<tr class="row-odd"><td><p>Using <code class="docutils literal notranslate"><span class="pre">cat</span></code> to read stdin</p></td>
<td><p>Signing command deadlocks</p></td>
<td><p>Use <code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">-t</span> <span class="pre">2</span></code> or <code class="docutils literal notranslate"><span class="pre">readline()</span></code> – pkg keeps stdin open</p></td>
</tr>
<tr class="row-even"><td><p>Fingerprint from DER key</p></td>
<td><p>“No trusted public keys found”</p></td>
<td><p>Fingerprint is <code class="docutils literal notranslate"><span class="pre">SHA256(PEM</span> <span class="pre">file)</span></code>, headers and all</p></td>
</tr>
<tr class="row-odd"><td><p>Testing with <code class="docutils literal notranslate"><span class="pre">openssl</span> <span class="pre">dgst</span> <span class="pre">-verify</span></code></p></td>
<td><p>Valid signatures appear to fail</p></td>
<td><p>Tests single hash, not pkg’s double hash; use manual DigestInfo extraction</p></td>
</tr>
<tr class="row-even"><td><p>Stale remote gpg-agent socket</p></td>
<td><p>“remote port forwarding failed”</p></td>
<td><p>Kill agent and remove socket in a <em>separate</em> SSH call before <code class="docutils literal notranslate"><span class="pre">-R</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">pkg</span> <span class="pre">repo</span></code> exit code</p></td>
<td><p>Build succeeds but repo is unsigned</p></td>
<td><p>Check for <code class="docutils literal notranslate"><span class="pre">meta.conf</span></code> existence after <code class="docutils literal notranslate"><span class="pre">pkg</span> <span class="pre">repo</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Using <code class="docutils literal notranslate"><span class="pre">gpg</span> <span class="pre">--sign</span></code></p></td>
<td><p>Produces OpenPGP format, not PKCS#1</p></td>
<td><p>Use <code class="docutils literal notranslate"><span class="pre">gpg-connect-agent</span></code> with <code class="docutils literal notranslate"><span class="pre">PKSIGN</span></code> for raw RSA</p></td>
</tr>
</tbody>
</table>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Link to this heading"></a></h2>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id9" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://man.freebsd.org/cgi/man.cgi?query=pkg-repo&amp;sektion=8">pkg-repo(8) man page</a>
– documents the <code class="docutils literal notranslate"><span class="pre">signing_command</span></code> output format and states that the SHA256
of the catalogue is passed on stdin.</p>
</aside>
<aside class="footnote brackets" id="id10" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id8">2</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://man.freebsd.org/cgi/man.cgi?query=pkg.conf&amp;sektion=5">pkg.conf(5) man page</a>
– documents <code class="docutils literal notranslate"><span class="pre">SIGNATURE_TYPE</span></code>, <code class="docutils literal notranslate"><span class="pre">FINGERPRINTS</span></code>, and the fingerprint file
format (<code class="docutils literal notranslate"><span class="pre">function:</span> <span class="pre">sha256</span></code>, <code class="docutils literal notranslate"><span class="pre">fingerprint:</span> <span class="pre">...</span></code>).</p>
</aside>
<aside class="footnote brackets" id="id11" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">3</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/freebsd/pkg/blob/main/scripts/sign.sh">scripts/sign.sh</a>
– the official example signing script in the freebsd/pkg repository. Uses
<code class="docutils literal notranslate"><span class="pre">read</span> <span class="pre">-t</span> <span class="pre">2</span></code> and <code class="docutils literal notranslate"><span class="pre">openssl</span> <span class="pre">dgst</span> <span class="pre">-sign</span> <span class="pre">-sha256</span></code>.</p>
</aside>
<aside class="footnote brackets" id="id12" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">4</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/freebsd/pkg/blob/main/libpkg/pkgsign_ossl.c">libpkg/pkgsign_ossl.c</a>
– OpenSSL signing and verification implementation. Contains
<code class="docutils literal notranslate"><span class="pre">EVP_md_pkg_sha1()</span></code> (custom digest with SHA-1 OID, result size 64) and
<code class="docutils literal notranslate"><span class="pre">ossl_verify_cb</span></code> (verification using <code class="docutils literal notranslate"><span class="pre">pkg_checksum_fd</span></code> with
<code class="docutils literal notranslate"><span class="pre">PKG_HASH_TYPE_SHA256_HEX</span></code>).</p>
</aside>
<aside class="footnote brackets" id="id13" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id2">5</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/freebsd/pkg/blob/main/libpkg/pkg_repo_create.c">libpkg/pkg_repo_create.c</a>
– repository creation code. Shows the hash written to stdin via
<code class="docutils literal notranslate"><span class="pre">fprintf</span></code>/<code class="docutils literal notranslate"><span class="pre">fflush</span></code>, with <code class="docutils literal notranslate"><span class="pre">fclose</span></code> deferred until after reading the
response.</p>
</aside>
<aside class="footnote brackets" id="id14" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">6</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://github.com/freebsd/pkg/blob/main/libpkg/pkg_repo.c">libpkg/pkg_repo.c</a>
– fingerprint verification code. Computes <code class="docutils literal notranslate"><span class="pre">pkg_checksum_data(s-&gt;cert,</span>
<span class="pre">s-&gt;certlen,</span> <span class="pre">PKG_HASH_TYPE_SHA256_HEX)</span></code> where <code class="docutils literal notranslate"><span class="pre">cert</span></code> is the PEM data
returned by the signing command.</p>
</aside>
<aside class="footnote brackets" id="id15" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id7">7</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://www.gnupg.org/documentation/manuals/gnupg/Agent-Options.html">GnuPG Agent Options</a>
– documents the extra socket (<code class="docutils literal notranslate"><span class="pre">agent-extra-socket</span></code>) intended for
forwarding to remote machines.</p>
</aside>
<aside class="footnote brackets" id="id16" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">8</a><span class="fn-bracket">]</span></span>
<p><a class="reference external" href="https://wiki.gnupg.org/AgentForwarding">GnuPG Agent Forwarding</a>
– GnuPG wiki page on forwarding gpg-agent to a remote system over SSH.</p>
</aside>
</aside>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../releases/26.1/metrics_exporter.html" class="btn btn-neutral float-left" title="Metrics Exporter" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright Brendan Bank. Licensed under the BSD 2-Clause License.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>